{
    "comments": [
        {
            "tags": [],
            "description": {
                "full": "<p>Functions \"each\", \"extend\", and \"isFunction\" based on Underscore.js 1.5.2<br />  <a href='http://underscorejs.org'>http://underscorejs.org</a><br />  (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors<br />  Underscore may be freely distributed under the MIT license.</p>",
                "summary": "<p>Functions \"each\", \"extend\", and \"isFunction\" based on Underscore.js 1.5.2<br />  <a href='http://underscorejs.org'>http://underscorejs.org</a><br />  (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors<br />  Underscore may be freely distributed under the MIT license.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "(function() {",
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var root = this;\n  var breaker = {};\n\n  // Create a safe reference to the d4 object.\n  var d4 = function(obj) {\n    if (obj instanceof d4) {\n      return obj;\n    }\n    if (!(this instanceof d4)) {\n      return new d4(obj);\n    }\n    this.d4Wrapped = obj;\n  };\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = d4;\n    }\n    exports.d4 = d4;\n  } else {\n    root.d4 = d4;\n  }\n\n  d4.features = {};\n  d4.parsers = {};\n\n  var each = d4.each = d4.forEach = function(obj, iterator, context) {\n    var nativeForEach = Array.prototype.forEach,\n      i, len;\n    if (obj === null) {\n      return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) {\n          return;\n        }\n      }\n    } else {\n      var keys = d3.keys(obj);\n      for (i = 0, len = keys.length; i < len; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) {\n          return;\n        }\n      }\n    }\n  };\n\n  var isFunction = function(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n  };\n\n  var isNotFunction = function(obj) {\n    return !isFunction(obj);\n  };\n\n  var assert = function(message) {\n    throw new Error('[d4] ' + message);\n  };\n\n  var validateBuilder = function(builder) {\n    each(['configure', 'render'], function(funct) {\n      if (!builder[funct] || isNotFunction(builder[funct])) {\n        assert('The supplied builder does not have a ' + funct + ' function');\n      }\n    });\n    return builder;\n  };\n\n  var assignDefaultBuilder = function(defaultBuilder) {\n    if (!this.builder) {\n      this.builder = validateBuilder(defaultBuilder.bind(this)());\n    }\n    return this;\n  };\n\n  var assignDefaults = function(config, defaultBuilder) {\n    if (!defaultBuilder) {\n      assert('No builder defined');\n    }\n    var opts = d4.merge({\n      width: 400,\n      height: 400,\n      features: {},\n      mixins: [],\n      xKey: 'x',\n      yKey: 'y',\n      valueKey: 'y',\n      margin: {\n        top: 20,\n        right: 20,\n        bottom: 20,\n        left: 40\n      }\n    }, config);\n    assignDefaultBuilder.bind(opts)(defaultBuilder);\n    opts.accessors = ['margin', 'width', 'height', 'x', 'y', 'xKey', 'yKey', 'valueKey'].concat(config.accessors || []);\n    return opts;\n  };\n\n  var build = function(data) {\n    if (this.builder) {\n      this.builder.configure(data);\n      this.builder.render(data);\n    } else {\n      assert('No builder defined');\n    }\n  };\n\n  var scaffoldChart = function(selection, data) {\n    this.svg = d3.select(selection).selectAll('svg').data([data]);\n    this.featuresGroup = this.svg.enter().append('svg').append('g')\n      .attr('class', 'featuresGroup')\n      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');\n    this.svg.attr('width', this.width).attr('height', this.height).attr('class', 'd4');\n    this.svg.append('defs');\n  };\n\n  var applyScaffold = function(opts) {\n    return function(selection) {\n      selection.each(function(data) {\n        scaffoldChart.bind(opts, this)(data);\n        build.bind(opts)(data);\n      });\n    };\n  };\n\n  var extractOverrides = function(feature) {\n    if (feature.overrides) {\n      return feature.overrides(this);\n    } else {\n      return {};\n    }\n  };\n\n  var mixin = function(feature, index) {\n    if (!feature) {\n      assert('You need to supply an object to mixin.');\n    }\n    var name = d3.keys(feature)[0];\n    var overrides = extractOverrides.bind(this)(feature, name);\n    feature[name] = d4.merge(feature[name](name), overrides);\n    d4.extend(this.features, feature);\n    if (typeof index !== 'undefined') {\n      index = Math.max(Math.min(index, this.mixins.length), 0);\n      this.mixins.splice(index, 0, name);\n    } else {\n      this.mixins.push(name);\n    }",
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>FIXME: see fixme note related to the chart accessor functions, the same<br />    problem applies here.</p>",
                "summary": "<p>FIXME: see fixme note related to the chart accessor functions, the same<br />    problem applies here.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "var accessors = this.features[name].accessors;\n    if (accessors) {\n      d3.keys(accessors).forEach(function(functName) {\n        this.features[name][functName] = function(attr) {\n          if (!arguments.length) {\n            return this.features[name].accessors[functName];\n          }\n          this.features[name].accessors[functName] = attr;\n          return this.features[name];\n        }.bind(this);\n      }, this);\n    }\n  };\n\n  var mixout = function(name) {\n    if (!name) {\n      assert('A name is required in order to mixout a chart feature.');\n    }\n\n    delete this.features[name];\n    this.mixins = this.mixins.filter(function(val) {\n      return val !== name;\n    });\n  };\n\n  var using = function(name, funct) {\n    var feature = this.features[name];\n    if (isNotFunction(funct)) {\n      assert('You must supply a continuation function in order to use a chart feature.');\n    }\n    if (!feature) {\n      assert('Could not find feature: \"' + name + '\", maybe you forgot to mix it in?');\n    } else {\n      funct.bind(this)(feature);\n    }\n  };",
            "ctx": {
                "type": "declaration",
                "name": "accessors",
                "value": "this.features[name].accessors",
                "string": "accessors"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Varies"
                    ],
                    "name": "funct",
                    "description": "- An function or other variable to be wrapped in a function"
                }
            ],
            "description": {
                "full": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                "summary": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "d4.functor = function(funct) {\n    return isFunction(funct) ? funct : function() {\n      return funct;\n    };\n  };\n\n  d4.baseChart = function(config, defaultBuilder) {\n    var opts = assignDefaults(config, defaultBuilder);\n    var chart = applyScaffold(opts);",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "functor",
                "string": "d4.functor()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>FIXME: d4 wraps the inner property object <code>opts</code> in a series of class<br />    functions. For example: <code>chart.width(300)</code> will set the internal<br />    <code>opts.width</code> property to 300. Additionally chart.width() will return 300.<br />    However, this behavior creates ambiguity in API because it is unclear to the<br />    developer which accessors require functions and which can simply supply<br />    values. Ideally the API should support something like this:<br />    chart.xKey('foo') or chart.xKey(function(){ return 'foo'; })<br />    Presently only the latter is allowed, which is confusing.</p>",
                "summary": "<p>FIXME: d4 wraps the inner property object <code>opts</code> in a series of class<br />    functions. For example: <code>chart.width(300)</code> will set the internal<br />    <code>opts.width</code> property to 300. Additionally chart.width() will return 300.<br />    However, this behavior creates ambiguity in API because it is unclear to the<br />    developer which accessors require functions and which can simply supply<br />    values. Ideally the API should support something like this:<br />    chart.xKey('foo') or chart.xKey(function(){ return 'foo'; })<br />    Presently only the latter is allowed, which is confusing.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "chart.accessors = opts.accessors;\n    chart.accessors.forEach(function(accessor) {\n      chart[accessor] = function(attr) {\n        if (!arguments.length) {\n          return opts[accessor];\n        }\n        opts[accessor] = attr;\n        return chart;\n      };\n    });",
            "ctx": {
                "type": "property",
                "receiver": "chart",
                "name": "accessors",
                "value": "opts.accessors",
                "string": "chart.accessors"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                },
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will perform the modifcation."
                }
            ],
            "description": {
                "full": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>\n\n<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>",
                "summary": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "chart.using = function(name, funct) {\n      using.bind(opts)(name, funct);\n      return chart;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "using",
                "string": "chart.using()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "Object"
                    ],
                    "name": "feature",
                    "description": "- an object describing the feature to mix in."
                },
                {
                    "type": "param",
                    "types": [
                        "Integer"
                    ],
                    "name": "index",
                    "description": "- an optional number to specify the insertion layer."
                }
            ],
            "description": {
                "full": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>",
                "summary": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "chart.mixin = function(feature, index) {\n      mixin.bind(opts)(feature, index);\n      return chart;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "mixin",
                "string": "chart.mixin()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [
                {
                    "type": "param",
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                }
            ],
            "description": {
                "full": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                "summary": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "chart.mixout = function(feature, index) {\n      mixout.bind(opts)(feature, index);\n      return chart;\n    };\n\n    chart.builder = function(funct) {\n      validateBuilder(funct.bind(chart)(opts));\n      return chart;\n    };",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "mixout",
                "string": "chart.mixout()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>To see what features are currently mixed into your chart you can use<br />this method.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                "summary": "<p>To see what features are currently mixed into your chart you can use<br />this method.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
            },
            "ignore": false,
            "code": "chart.features = function() {\n      return opts.mixins;\n    };\n\n    return chart;\n  };\n\n  d4.merge = function(options, overrides) {\n    return d4.extend(d4.extend({}, options), overrides);\n  };\n\n  d4.extend = function(obj) {\n    each(Array.prototype.slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (source[prop] && source[prop].constructor &&\n            source[prop].constructor === Object) {\n            obj[prop] = obj[prop] || {};\n            d4.extend(obj[prop], source[prop]);\n          } else {\n            obj[prop] = source[prop];\n          }\n        }\n      }\n    });\n    return obj;\n  };\n\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "chart",
                "name": "features",
                "string": "chart.features()"
            },
            "fileName": "../src/base.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.arrow = function(name) {\n    return {\n      accessors: {\n        tipSize: function(){\n          return 6;\n        },\n        x1: function() {\n          return this.x(0);\n        },\n\n        x2: function() {\n          return this.x(this.width - this.margin.left - this.margin.right);\n        },\n\n        y1: function() {\n          return this.y(0);\n        },\n\n        y2: function() {\n          return  this.y(this.height - this.margin.top - this.margin.bottom);\n        }\n      },\n      render: function(scope) {\n        var defs = this.svg.select('defs');\n\n        defs.append('marker')\n          .attr('id', name + '-end')\n          .attr('viewBox', '0 0 10 10')\n          .attr('refX', 10)\n          .attr('refY', 5)\n          .attr('markerWidth', scope.accessors.tipSize.bind(this))\n          .attr('markerHeight', scope.accessors.tipSize.bind(this))\n          .attr('orient', 'auto')\n          .append('path')\n          .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n        defs.append('marker')\n          .attr('id', name + '-start')\n          .attr('viewBox', '0 0 10 10')\n          .attr('refX', 10)\n          .attr('refY', 5)\n          .attr('markerWidth', -scope.accessors.tipSize.bind(this)())\n          .attr('markerHeight', scope.accessors.tipSize.bind(this))\n          .attr('orient', 'auto')\n          .append('path')\n          .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n        this.featuresGroup.append('g').attr('class', name);\n        var arrow = this.svg.select('.' + name)\n          .append('line')\n          .attr('class', 'line')\n          .attr('x1', scope.accessors.x1.bind(this))\n          .attr('x2', scope.accessors.x2.bind(this))\n          .attr('y1', scope.accessors.y1.bind(this))\n          .attr('y2', scope.accessors.y2.bind(this))\n          .attr('marker-end', 'url(#' + name + '-end)');\n\n        return arrow;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/arrow.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.columnLabels = function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d[this.xKey]) + (this.x.rangeBand() / 2);\n        },\n\n        y: function(d) {\n          var height = Math.abs(this.y(d[this.yKey]) - this.y(0));\n          return (d[this.yKey] < 0 ? this.y(d[this.yKey]) - height : this.y(d[this.yKey])) - 5;\n        },\n\n        text: function(d) {\n          return d3.format('').call(this, d[this.yKey]);\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var label = this.svg.select('.'+name).selectAll('.'+name).data(data);\n        label.enter().append('text');\n        label.exit().remove();\n        label.attr('class', 'column-label')\n          .text(scope.accessors.text.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this));\n        return label;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/column-labels.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>DEPRECATION WARNING: This feature is deprecated in favor of using the nested<br />  column series renderer. Intrinsicly this makes sense because a normal column<br />  chart is mearly a stacked column chart with only one series.</p>",
                "summary": "<p>DEPRECATION WARNING: This feature is deprecated in favor of using the nested<br />  column series renderer. Intrinsicly this makes sense because a normal column<br />  chart is mearly a stacked column chart with only one series.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "(function() {",
            "fileName": "../src/features/column-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.columnSeries = function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d[this.xKey]);\n        },\n\n        y: function(d) {\n          return d[this.yKey] < 0 ? this.y(0) : this.y(d[this.yKey]);\n        },\n\n        width: function() {\n          return this.x.rangeBand();\n        },\n\n        height: function(d) {\n          return Math.abs(this.y(d[this.yKey]) - this.y(0));\n        },\n\n        classes: function(d, i) {\n          return d[this.yKey] < 0 ? 'bar negative fill series' + i : 'bar positive fill series' + i;\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var series = this.svg.select('.' + name).selectAll('.' + name + 'Series').data(data);\n        series.enter().append('g');\n        series.exit().remove();\n        series.attr('class', function(d, i) {\n          return 'series' + i;\n        });\n\n        var bar = series.selectAll('rect').data(function(d) {\n          return [d];\n        });\n        bar.enter().append('rect');\n        bar.exit().remove();\n        bar.attr('class', scope.accessors.classes.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('width', scope.accessors.width.bind(this))\n          .attr('height', scope.accessors.height.bind(this));\n\n        return bar;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/column-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.grid = function(name) {\n\n    return {\n      accessors: {\n        formatXAxis: function(xAxis) {\n          return xAxis.orient('bottom');\n        },\n\n        formatYAxis: function(yAxis) {\n          return yAxis.orient('left');\n        }\n      },\n      render: function(scope) {\n        var xAxis = d3.svg.axis().scale(this.x);\n        var yAxis = d3.svg.axis().scale(this.y);\n        var formattedXAxis = scope.accessors.formatXAxis.bind(this)(xAxis);\n        var formattedYAxis = scope.accessors.formatYAxis.bind(this)(yAxis);\n\n        this.featuresGroup.append('g').attr('class', 'grid border '+ name)\n          .attr('transform', 'translate(0,0)')\n          .append('rect')\n          .attr('x', 0)\n          .attr('y', 0)\n          .attr('width', this.width - this.margin.left - this.margin.right)\n          .attr('height', this.height - this.margin.top - this.margin.bottom);\n\n        this.featuresGroup.append('g').attr('class', 'x grid '+ name)\n          .attr('transform', 'translate(0,' + (this.height - this.margin.top - this.margin.bottom) + ')')\n          .call(formattedXAxis\n          .tickSize(-(this.height - this.margin.top - this.margin.bottom), 0, 0)\n          .tickFormat(''));\n\n        this.featuresGroup.append('g').attr('class', 'y grid '+ name)\n          .attr('transform', 'translate(0,0)')\n          .call(formattedYAxis\n          .tickSize(-(this.width - this.margin.left - this.margin.right), 0, 0)\n          .tickFormat(''));\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/grid.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.groupedColumnLabels = function(name) {\n    return {\n      accessors: {\n        x: function(d, i) {\n          var width = this.x.rangeBand() / this.groupsOf;\n          var xPos = this.x(d[this.xKey]) + width * i;\n          var gutter = width * 0.1;\n          return xPos + width/2 - gutter;\n        },\n\n        y: function(d) {\n          return (d[this.yKey] < 0 ? this.y(0) : this.y(d[this.yKey])) -5;\n        },\n\n        text: function(d) {\n          return d3.format('').call(this, d[this.yKey]);\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data)\n          .enter().append('g')\n          .attr('class', function(d,i) {\n            return 'series'+ i +  ' ' + this.xKey;\n          }.bind(this));\n\n        var text = group.selectAll('text')\n          .data(function(d) {\n            return d.values;\n          }.bind(this));\n        text.exit().remove();\n        text.enter().append('text')\n          .attr('class', 'column-label')\n          .text(scope.accessors.text.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('x', scope.accessors.x.bind(this));\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/grouped-column-labels.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.groupedColumnSeries = function(name) {\n    var sign = function(val) {\n      return (val > 0) ? 'positive' : 'negative';\n    };\n\n    return {\n      accessors: {\n        x: function(d, i) {\n          var width = this.x.rangeBand() / this.groupsOf;\n          var xPos = this.x(d[this.xKey]) + width * i;\n          return xPos;\n        },\n\n        y: function(d) {\n          return d[this.yKey] < 0 ? this.y(0) : this.y(d[this.yKey]);\n        },\n\n        width: function() {\n          var width = this.x.rangeBand() / this.groupsOf;\n          var gutter = width * 0.1;\n          return width - gutter;\n        },\n\n        height: function(d) {\n          return Math.abs(this.y(d[this.yKey]) - this.y(0));\n        },\n\n        classes: function(d, i) {\n          return 'bar fill item' + i + ' ' + sign(d[this.yKey]) + ' ' + d[this.yKey];\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data);\n        group.enter().append('g');\n        group.exit().remove();\n        group.attr('class', function(d, i) {\n          return 'series' + i + ' ' + this.xKey;\n        }.bind(this));\n\n        group.selectAll('rect')\n          .data(function(d) {\n            return d.values;\n          }.bind(this))\n          .enter().append('rect')\n          .attr('class', scope.accessors.classes.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('width', scope.accessors.width.bind(this))\n          .attr('height', scope.accessors.height.bind(this));\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/grouped-column-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.lineSeriesLabels = function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d.values[d.values.length - 1][this.xKey]);\n        },\n\n        y: function(d) {\n          return this.y(d.values[d.values.length - 1][this.yKey]);\n        },\n\n        text: function(d) {\n          return d.key;\n        },\n\n        classes: function(d,n) {\n          return 'stroke series' + n;\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var label = this.svg.select('.'+name).selectAll('.'+name).data(data);\n        label.enter().append('text');\n        label.exit().remove();\n        label.attr('class', 'lineSeriesLabel')\n          .text(scope.accessors.text.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('data-key', function(d){\n            return d.key;\n          })\n          .attr('class', scope.accessors.classes.bind(this));\n        return label;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/line-series-labels.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.lineSeries = function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d[this.xKey]);\n        },\n        y: function(d) {\n          return this.y(d[this.yKey]);\n        },\n        interpolate: function() {\n          return 'basis';\n        },\n        classes: function(d, n) {\n          return 'line stroke series' + n;\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var line = d3.svg.line()\n          .interpolate(scope.accessors.interpolate.bind(this)())\n          .x(scope.accessors.x.bind(this))\n          .y(scope.accessors.y.bind(this));\n\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data);\n        group.exit().remove();\n        group.enter().append('g')\n          .attr('data-key', function(d) {\n            return d.key;\n          })\n          .attr('class', function(d, i) {\n            return 'series' + i;\n          }.bind(this))\n          .append('path')\n          .attr('d', function(d) {\n            return line(d.values);\n          });\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/line-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.referenceLine = function(name) {\n    return {\n      accessors: {\n        x1: function() {\n          return this.x(0);\n        },\n\n        x2: function() {\n          return this.x(this.width - this.margin.left - this.margin.right);\n        },\n\n        y1: function() {\n          return this.y(0);\n        },\n\n        y2: function() {\n          return this.y(this.height);\n        }\n      },\n      render: function(scope) {\n        this.featuresGroup.append('g').attr('class', name);\n        var referenceLine = this.svg.select('.' + name)\n          .append('line')\n          .attr('class', 'line')\n          .attr('x1', scope.accessors.x1.bind(this))\n          .attr('x2', scope.accessors.x2.bind(this))\n          .attr('y1', scope.accessors.y1.bind(this))\n          .attr('y2', scope.accessors.y2.bind(this));\n        return referenceLine;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/reference-line.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.rowLabels = function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(Math.min(0, d[this.xKey])) + Math.abs(this.x(d[this.xKey]) - this.x(0)) + 20;\n        },\n\n        y: function(d) {\n          return this.y(d[this.yKey]) + (this.y.rangeBand() / 2);\n        },\n\n        text: function(d) {\n          return d3.format('').call(this, d[this.xKey]);\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var label = this.svg.select('.'+name).selectAll('.'+name).data(data);\n        label.enter().append('text');\n        label.exit().remove();\n        label.attr('class', 'column-label')\n          .text(scope.accessors.text.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this));\n        return label;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/row-labels.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.rowSeries = function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(Math.min(0, d[this.xKey]));\n        },\n\n        y: function(d) {\n          return this.y(d[this.yKey]);\n        },\n\n        height: function() {\n          return this.y.rangeBand();\n        },\n\n        width: function(d) {\n          return Math.abs(this.x(d[this.xKey]) - this.x(0));\n        },\n\n        classes: function(d, i) {\n          return d[this.xKey] < 0 ? 'bar negative fill series' + i : 'bar positive fill series' + i;\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var bar = this.svg.select('.'+name).selectAll('.'+name).data(data);\n        bar.enter().append('rect');\n        bar.exit().remove();\n        bar.attr('class', scope.accessors.classes.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('width', scope.accessors.width.bind(this))\n          .attr('height', scope.accessors.height.bind(this));\n\n        return bar;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/row-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.scatterSeries = function(name) {\n    return {\n      accessors: {\n        cx: function(d) {\n          return this.x(d[this.xKey]);\n        },\n\n        cy: function(d) {\n          return this.y(d[this.yKey]);\n        },\n\n        r: function(d) {\n          return this.z(d[this.zKey]);\n        },\n\n        classes : function(d, i) {\n          return 'dot series' + i + ' fill';\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var dot = this.svg.select('.'+name).selectAll('.'+name).data(data);\n        dot.enter().append('circle');\n        dot.attr('class', scope.accessors.classes.bind(this))\n        .attr('r', scope.accessors.r.bind(this))\n        .attr('cx', scope.accessors.cx.bind(this))\n        .attr('cy', scope.accessors.cy.bind(this));\n        return dot;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/scatter-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/features/stacked-column-connectors.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Column connectors helpful when displaying a stacked column chart.<br />    A connector will not connect positve and negative columns. This is because<br />    in a stacked column a negative column may move many series below its previous<br />    location. This creates a messy collection of crisscrossing lines.</p>",
                "summary": "<p>Column connectors helpful when displaying a stacked column chart.<br />    A connector will not connect positve and negative columns. This is because<br />    in a stacked column a negative column may move many series below its previous<br />    location. This creates a messy collection of crisscrossing lines.</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.stackedColumnConnectors = function(name) {\n\n    return {\n      accessors: {\n        x1: function(d) {\n          var width = 0;\n          var xVal = (d.y0 + d.y) - Math.max(0, d.y);\n          if(d.y > 0){\n            width = Math.abs(this.x(d.y0) - this.x(d.y0 + d.y));\n          }\n          return this.x(xVal) + width;\n\n        },\n\n        y1: function(d) {\n          return this.y(d[this.yKey]);\n        },\n\n        span: function(){\n          return this.y.rangeBand();\n        },\n\n        classes : function(d, i){\n          return 'series' +i;\n        }\n      },\n\n      render: function(scope) {\n        this.featuresGroup.append('g').attr('class', name);\n        var lines = this.svg.select('.' + name).selectAll('.' + name).data(function(d) {\n          return d.map(function(o) {\n            return o.values[0];\n          });\n        }.bind(this));\n        lines.enter().append('line');\n        lines.exit().remove();\n        lines\n        .attr('class', scope.accessors.classes.bind(this))\n        .attr('x1', function() {\n          // if(i === 0){\n          //   return 0;\n          // }\n          // return scope.accessors.x1.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('y1', function() {\n          // if(i === 0){\n          //   return 0;\n          // }\n          // return scope.accessors.y1.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('x2', function() {\n          // if(i === 0){\n          //   return 0;\n          // }\n          // return scope.accessors.x1.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('y2', function() {\n          // if(i === 0){\n          //   return 0;\n          // }\n          // return scope.accessors.y1.bind(this)(d) + scope.accessors.span.bind(this)(d);\n        }.bind(this));\n\n        return lines;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/stacked-column-connectors.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.stackedColumnLabels = function(name) {\n    var sign = function(val) {\n      return val > 0 ? 'positive' : 'negative';\n    };\n\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d[this.xKey]) + (this.x.rangeBand() / 2);\n        },\n\n        y: function(d) {\n          var halfHeight = Math.abs(this.y(d.y0) - this.y(d.y0 + d.y)) / 2;\n          var yVal = d.y0 + d.y;\n          return (yVal < 0 ? this.y(d.y0) : this.y(yVal)) + halfHeight;\n        },\n\n        text: function(d) {\n          if(Math.abs(this.y(d.y0) - this.y(d.y0 + d.y)) > 20) {\n            return d3.format('').call(this, d[this.valueKey]);\n          }\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data)\n          .enter().append('g')\n          .attr('class', function(d, i) {\n            return 'series' + i + ' '+ sign(d.y) + ' ' + this.xKey;\n          }.bind(this));\n\n        var text = group.selectAll('text')\n          .data(function(d) {\n            return d.values;\n          }.bind(this));\n        text.exit().remove();\n        text.enter().append('text')\n          .text(scope.accessors.text.bind(this))\n          .attr('class', 'column-label')\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('x', scope.accessors.x.bind(this));\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/stacked-column-labels.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.stackedColumnSeries = function(name) {\n    var sign = function(val){\n      return (val > 0) ? 'positive' : 'negative';\n    };\n\n    return {\n      accessors: {\n        x: function(d) {\n          return this.x(d[this.xKey]);\n        },\n\n        y: function(d) {\n          var yVal = d.y0 + d.y;\n          return  yVal < 0 ? this.y(d.y0) : this.y(yVal);\n        },\n\n        width: function() {\n          return this.x.rangeBand();\n        },\n\n        height: function(d) {\n          return Math.abs(this.y(d.y0) - this.y(d.y0 + d.y));\n        },\n\n        classes: function(d,i) {\n          return 'bar fill item'+ i + ' ' + sign(d.y) + ' ' + d[this.yKey];\n        }\n      },\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var group = this.svg.select('.' + name).selectAll('.group')\n          .data(data)\n          .enter().append('g')\n          .attr('class', function(d,i) {\n            return 'series'+ i + ' ' +  this.yKey;\n          }.bind(this));\n\n        group.selectAll('rect')\n          .data(function(d) {\n            return d.values;\n          }.bind(this))\n          .enter().append('rect')\n          .attr('class', scope.accessors.classes.bind(this))\n          .attr('x', scope.accessors.x.bind(this))\n          .attr('y', scope.accessors.y.bind(this))\n          .attr('width', scope.accessors.width.bind(this))\n          .attr('height', scope.accessors.height.bind(this));\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/stacked-column-series.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.trendLine = function(name) {\n    return {\n      accessors: {\n        x1: function() {\n          return this.x(0);\n        },\n\n        x2: function() {\n          return this.x(this.width);\n        },\n\n        y1: function() {\n          return this.y(0);\n        },\n\n        y2: function() {\n          return this.y(this.height);\n        },\n\n        text: function(d) {\n          return d3.format('').call(this, d[1]);\n        },\n\n        textX: function() {\n          return this.x(this.width);\n        },\n\n        textY: function(){\n          return this.x(this.height);\n        }\n      },\n      render: function(scope) {\n        var defs = this.svg.select('defs');\n\n        defs.append('marker')\n          .attr('id', name + '-start')\n          .attr('viewBox', '0 0 10 10')\n          .attr('refX', 10)\n          .attr('refY', 5)\n          .attr('markerWidth', -6)\n          .attr('markerHeight', 6)\n          .attr('orient', 'auto')\n          .append('path')\n          .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n        this.featuresGroup.append('g').attr('class', name);\n        var trendLine = this.svg.select('.' + name)\n          .append('line')\n          .attr('class', 'line')\n          .attr('x1', scope.accessors.x1.bind(this))\n          .attr('x2', scope.accessors.x2.bind(this))\n          .attr('y1', scope.accessors.y1.bind(this))\n          .attr('y2', scope.accessors.y2.bind(this))\n          .attr('marker-end', 'url(#' + name + '-start)');\n\n        this.svg.select('.' + name)\n          .append('text')\n          .attr('class', 'trendLine-label')\n          .text(scope.accessors.text.bind(this))\n          .attr('x', scope.accessors.textX.bind(this))\n          .attr('y', scope.accessors.textY.bind(this));\n        return trendLine;\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/trend-line.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/features/waterfall-connectors.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>\n\n<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>",
                "summary": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>",
                "body": "<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>"
            },
            "ignore": false,
            "code": "d4.features.waterfallConnectors = function(name) {\n    return {\n      accessors: {\n        x: function(d) {\n          if(this.orientation() === 'horizontal'){\n            var width = 0;\n            var xVal = (d.y0 + d.y) - Math.max(0, d.y);\n            if(d.y > 0){\n              width = Math.abs(this.x(d.y0) - this.x(d.y0 + d.y));\n            }\n            return this.x(xVal) + width;\n          } else {\n            return this.x(d[this.xKey]);\n          }\n        },\n\n        y: function(d) {\n          if(this.orientation() === 'horizontal'){\n            return this.y(d[this.yKey]);\n          } else {\n            return this.y(d.y0 + d.y);\n          }\n        },\n\n        span: function(){\n          if(this.orientation() === 'horizontal'){\n            return this.y.rangeBand();\n          } else {\n            return this.x.rangeBand();\n          }\n        },\n\n        classes : function(d, i){\n          return 'series' +i;\n        }\n      },\n\n      render: function(scope, data) {\n        this.featuresGroup.append('g').attr('class', name);\n        var lines = this.svg.select('.' + name).selectAll('.' + name).data(function(d) {\n          return d.map(function(o) {\n            return o.values[0];\n          });\n        }.bind(this));\n        lines.enter().append('line');\n        lines.exit().remove();\n        lines\n        .attr('class', scope.accessors.classes.bind(this))\n        .attr('x1', function(d, i) {\n          if(i === 0){\n            return 0;\n          }\n          return scope.accessors.x.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('y1', function(d, i) {\n          if(i === 0){\n            return 0;\n          }\n          return scope.accessors.y.bind(this)(data[i - 1].values[0]);\n        }.bind(this))\n\n        .attr('x2', function(d, i) {\n          if(i === 0){\n            return 0;\n          }\n          if(this.orientation() === 'vertical') {\n            return scope.accessors.x.bind(this)(d) + scope.accessors.span.bind(this)();\n          } else {\n            return scope.accessors.x.bind(this)(data[i - 1].values[0]);\n          }\n        }.bind(this))\n\n        .attr('y2', function(d, i) {\n          if(i === 0){\n            return 0;\n          }\n          if(this.orientation() === 'vertical') {\n            return scope.accessors.y.bind(this)(data[i - 1].values[0]);\n          }else {\n            return scope.accessors.y.bind(this)(d) + scope.accessors.span.bind(this)(d);\n          }\n        }.bind(this));\n\n        return lines;\n      }\n    };\n  };\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "d4.features",
                "name": "waterfallConnectors",
                "string": "d4.features.waterfallConnectors()"
            },
            "fileName": "../src/features/waterfall-connectors.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.xAxis = function(name) {\n    return {\n      accessors: {\n        format: function(xAxis) {\n          return xAxis.orient('bottom').tickSize(0);\n        }\n      },\n      render: function(scope) {\n        var xAxis = d3.svg.axis().scale(this.x);\n        var formattedAxis = scope.accessors.format.bind(this)(xAxis);\n        this.featuresGroup.append('g').attr('class', 'x axis '+ name)\n          .attr('transform', 'translate(0,' + (this.height - this.margin.top - this.margin.bottom) + ')')\n          .call(formattedAxis);\n\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/x-axis.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  d4.features.yAxis = function(name) {\n\n    // FIXME: This should be a util function\n    // Extracted from: http://bl.ocks.org/mbostock/7555321\n    var wrap = function(text, width) {\n      text.each(function() {\n        var text = d3.select(this),\n            words = text.text().split(/\\s+/).reverse(),\n            word,\n            line = [],\n            lineNumber = 0,\n            lineHeight = 1.1, // ems\n            x = text.attr('x'),\n            y = text.attr('y'),\n            dy = parseFloat(text.attr('dy')),\n            tspan = text.text(null).append('tspan').attr('x', x).attr('y', y).attr('dy', dy + 'em');\n        word = words.pop();\n        while (word) {\n          line.push(word);\n          tspan.text(line.join(' '));\n          if (tspan.node().getComputedTextLength() > width - Math.abs(x)) {\n            line.pop();\n            tspan.text(line.join(' '));\n            line = [word];\n            tspan = text.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(word);\n          }\n          word = words.pop();\n        }\n      });\n    };\n\n    return {\n      accessors: {\n        format: function(yAxis) {\n          return yAxis.orient('left').tickSize(0);\n        }\n      },\n      render: function(scope) {\n        var yAxis = d3.svg.axis().scale(this.y);\n        var formattedAxis = scope.accessors.format.bind(this)(yAxis);\n        this.featuresGroup.append('g').attr('class', 'y axis ' + name)\n          .attr('transform', 'translate(0,0)')\n          .call(formattedAxis)\n          .selectAll('.tick text')\n          .call(wrap, this.margin.left);\n      }\n    };\n  };\n}).call(this);",
            "fileName": "../src/features/y-axis.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false</p>",
                "summary": "<p>global d3: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/parsers/nested-group.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d4: false</p>",
                "summary": "<p>global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';",
            "fileName": "../src/parsers/nested-group.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>\n\n<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>",
                "summary": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>",
                "body": "<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.parsers.nestedGroup = function nestedGroup() {\n\n    var opts = {\n      x: {\n        key: 'x',\n        values: []\n      },\n      y: {\n        key: 'y',\n        values: []\n      },\n      value: {\n        key: 'value',\n        values: []\n      },\n      data: []\n    };\n    opts.nestKey = function(){\n      return opts.x.key;\n    };\n\n    var findValues = function(dimensions, items) {\n      ['x', 'y', 'value'].forEach(function(k) {\n        var layers = items.map(function(d) {\n          return d[dimensions[k].key];\n        });\n        opts[k].values = d3.set(layers).values();\n      });\n    };\n\n    var nestByDimension = function(key, valueKey, items) {\n      var nest = d3.nest()\n        .key(function(d) {\n          return d[key];\n        });\n      return nest.entries(items);\n    };\n\n    var setDimension = function(dim, funct) {\n      opts[dim].key = d4.functor(funct)();\n    };\n\n    var parser = function(data) {\n      if (data) {\n        d4.extend(opts.data, data);\n      }\n\n      findValues(opts, opts.data);\n      opts.data = nestByDimension(opts.nestKey(), opts.value.key, opts.data);\n\n      return opts;\n    };\n\n    parser.nestKey = function(funct) {\n      opts.nestKey = funct.bind(opts);\n      return parser;\n    };\n\n    parser.x = function(funct) {\n      setDimension.bind(opts)('x', funct);\n      return parser;\n    };\n\n    parser.y = function(funct) {\n      setDimension.bind(opts)('y', funct);\n      return parser;\n    };\n\n    parser.value = function(funct) {\n      setDimension.bind(opts)('value', funct);\n      return parser;\n    };\n\n    return parser;\n  };\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "d4.parsers",
                "name": "nestedGroup",
                "string": "d4.parsers.nestedGroup()"
            },
            "fileName": "../src/parsers/nested-group.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false</p>",
                "summary": "<p>global d3: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/parsers/nested-stack.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d4: false</p>",
                "summary": "<p>global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';",
            "fileName": "../src/parsers/nested-stack.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>\n\n<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>",
                "summary": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>",
                "body": "<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.parsers.nestedStack = function nestedStack() {\n\n    var opts = {\n      x: {\n        key: 'x',\n        values: []\n      },\n      y: {\n        key: 'y',\n        values: []\n      },\n      value: {\n        key: 'value',\n        values: []\n      },\n      data: []\n    };\n\n    var findValues = function(dimensions, items) {\n      ['x', 'y', 'value'].forEach(function(k) {\n        var layers = items.map(function(d) {\n          return d[dimensions[k].key];\n        });\n        opts[k].values = d3.set(layers).values();\n      });\n    };\n\n    var nestByDimension = function(stackKey, valueKey, items) {\n      var nest = d3.nest()\n        .key(function(d) {\n          return d[stackKey];\n        });\n      return nest.entries(items);\n    };\n\n    // By default D3 doesn't handle stacks with negative values very well, we\n    // need to calulate or our y and y0 values for each group.\n    var stackByDimension = function(key, items) {\n      var offsets = {};\n\n      var stack = d3.layout.stack()\n        .values(function(d) {\n          return d.values;\n        })\n        .x(function(d) {\n          return d[key];\n        })\n        .y(function(d) {\n          return +d[opts.value.key];\n        })\n        .out(function(d, y0, y) {\n          d.y = y;\n          if (d.y >= 0) {\n            d.y0 = offsets[d[key] + 'Pos'] = offsets[d[key] + 'Pos'] || 0;\n            offsets[d[key] + 'Pos'] += y;\n          } else {\n            d.y0 = offsets[d[key] + 'Neg'] = offsets[d[key] + 'Neg'] || 0;\n            offsets[d[key] + 'Neg'] -= Math.abs(y);\n          }\n        });\n      stack(items.reverse());\n    };\n\n    var setDimension = function(dim, funct) {\n      opts[dim].key = d4.functor(funct)();\n    };\n\n    var parser = function(data) {\n      if (data) {\n        d4.extend(opts.data, data);\n      }\n\n      findValues(opts, opts.data);\n      opts.data = nestByDimension(opts.y.key, opts.value.key, opts.data);\n\n      stackByDimension(opts.x.key, opts.data);\n      return opts;\n    };\n\n    parser.x = function(funct) {\n      setDimension.bind(opts)('x', funct);\n      return parser;\n    };\n\n    parser.y = function(funct) {\n      setDimension.bind(opts)('y', funct);\n      return parser;\n    };\n\n    parser.value = function(funct) {\n      setDimension.bind(opts)('value', funct);\n      return parser;\n    };\n\n    return parser;\n  };\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "d4.parsers",
                "name": "nestedStack",
                "string": "d4.parsers.nestedStack()"
            },
            "fileName": "../src/parsers/nested-stack.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false</p>",
                "summary": "<p>global d3: false</p>",
                "body": ""
            },
            "ignore": true,
            "fileName": "../src/parsers/waterfall.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d4: false</p>",
                "summary": "<p>global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';",
            "fileName": "../src/parsers/waterfall.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>\n\n<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>",
                "summary": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>",
                "body": "<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>"
            },
            "ignore": false,
            "code": "d4.parsers.waterfall = function waterfall() {\n\n    var opts = {\n      x: {\n        key: 'x',\n        values: []\n      },\n      y: {\n        key: 'y',\n        values: []\n      },\n      value: {\n        key: 'value',\n        values: []\n      },\n      data: []\n    };\n    opts.nestKey = function(){\n      return opts.x.key;\n    };\n\n\n    var findValues = function(dimensions, items) {\n      ['x', 'y', 'value'].forEach(function(k) {\n        var layers = items.map(function(d) {\n          return d[dimensions[k].key];\n        });\n        opts[k].values = d3.set(layers).values();\n      });\n    };\n\n    var nestByDimension = function(key, valueKey, items) {\n      var nest = d3.nest()\n        .key(function(d) {\n          return d[key];\n        });\n      return nest.entries(items);\n    };\n\n    var stackByDimension = function(key, items) {\n      var lastOffset = 0;\n      var noNaN = function(num){\n        return isNaN(num) ? 0 : num;\n      };\n      var stack = d3.layout.stack()\n        .values(function(d) {\n          return d.values;\n        })\n        .x(function(d) {\n          return d[key];\n        })\n        .y(function(d) {\n          return +d[opts.value.key];\n        })\n        .out(function(d, y0, y) {\n          if(isNaN(y)){\n            if(isNaN(y0)){\n              y0 = lastOffset;\n            }\n            d.y0 = 0;\n            d.y = y0;\n            d[opts.value.key] = y0;\n            lastOffset = y0;\n          } else {\n            if(isNaN(y0)){\n              d.y0 = lastOffset;\n              lastOffset += y;\n            } else {\n              d.y0 = y0;\n            }\n            d.y = y;\n            d[opts.value.key] = noNaN(d[opts.value.key]);\n          }\n        });\n      stack(items);\n    };\n\n    var setDimension = function(dim, funct) {\n      opts[dim].key = d4.functor(funct)();\n    };\n\n    var parser = function(data) {\n      if (data) {\n        d4.extend(opts.data, data);\n      }\n\n      findValues(opts, opts.data);\n      opts.data = nestByDimension(opts.nestKey(), opts.value.key, opts.data);\n\n      stackByDimension(opts.x.key, opts.data);\n      return opts;\n    };\n\n    parser.nestKey = function(funct) {\n      opts.nestKey = funct.bind(opts);\n      return parser;\n    };\n\n    parser.x = function(funct) {\n      setDimension.bind(opts)('x', funct);\n      return parser;\n    };\n\n    parser.y = function(funct) {\n      setDimension.bind(opts)('y', funct);\n      return parser;\n    };\n\n    parser.value = function(funct) {\n      setDimension.bind(opts)('value', funct);\n      return parser;\n    };\n\n    return parser;\n  };\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "d4.parsers",
                "name": "waterfall",
                "string": "d4.parsers.waterfall()"
            },
            "fileName": "../src/parsers/waterfall.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n  var columnChartBuilder = function() {\n    var configureX = function(data) {\n      if (!this.parent.x) {\n        this.parent.xRoundBands = this.parent.xRoundBands || 0.3;\n        this.parent.x = d3.scale.ordinal()\n          .domain(data.map(function(d) {\n            return d[this.xKey];\n          }.bind(this.parent)))\n          .rangeRoundBands([0, this.parent.width - this.parent.margin.left - this.parent.margin.right], this.parent.xRoundBands);\n      }\n    };\n\n    var configureY = function(data) {\n      if (!this.parent.y) {\n        this.parent.y = d3.scale.linear()\n          .domain(d3.extent(data, function(d) {\n            return d[this.yKey];\n          }.bind(this.parent)));\n      }\n      this.parent.y.range([this.parent.height - this.parent.margin.top - this.parent.margin.bottom, 0])\n        .clamp(true)\n        .nice();\n    };\n\n    var configureScales = function(data) {\n      configureX.bind(this)(data);\n      configureY.bind(this)(data);\n    };\n\n    var builder = {\n      configure: function(data) {\n        configureScales.bind(this)(data);\n      },\n      render: function(data) {\n        var parent = this.parent;\n        parent.mixins.forEach(function(name) {\n          parent.features[name].render.bind(parent)(parent.features[name], data);\n        });\n      }\n    };\n\n    builder.parent = this;\n    return builder;\n  };",
            "fileName": "../src/charts/column-chart.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.columnChart();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.columnChart()\n.xKey(0)\n.yKey(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.columnChart();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.columnChart()\n.xKey(0)\n.yKey(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.columnChart = function columnChart() {\n    var chart = d4.baseChart({}, columnChartBuilder);\n    [{\n      'bars': d4.features.columnSeries\n    }, {\n      'barLabels': d4.features.columnLabels\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  };\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "columnChart",
                "string": "d4.columnChart()"
            },
            "fileName": "../src/charts/column-chart.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var groupedColumnChartBuilder = function() {\n    var extractValues = function(data, key) {\n      var values = data.map(function(obj){\n        return obj.values.map(function(i){\n          return i[key];\n        }.bind(this));\n      }.bind(this));\n      return d3.merge(values);\n    };\n\n    var configureX = function(data) {\n      if (!this.parent.x) {\n        var xData = extractValues(data, this.parent.xKey);\n        this.parent.xRoundBands = this.parent.xRoundBands || 0.3;\n        this.parent.x = d3.scale.ordinal()\n          .domain(xData)\n          .rangeRoundBands([0, this.parent.width - this.parent.margin.left - this.parent.margin.right], this.parent.xRoundBands);\n      }\n    };\n\n    var configureY = function(data) {\n      if (!this.parent.y) {\n        var yData = extractValues(data, this.parent.yKey);\n        var ext = d3.extent(yData);\n        this.parent.y = d3.scale.linear().domain([Math.min(0, ext[0]),ext[1]]);\n      }\n      this.parent.y.range([this.parent.height - this.parent.margin.top - this.parent.margin.bottom, 0])\n        .clamp(true)\n        .nice();\n    };\n\n    var configureScales = function(data) {\n      configureX.bind(this)(data);\n      configureY.bind(this)(data);\n    };\n\n    var builder = {\n      configure: function(data) {\n        configureScales.bind(this)(data);\n      },\n\n      render: function(data) {\n        var parent = this.parent;\n        parent.mixins.forEach(function(name) {\n          parent.features[name].render.bind(parent)(parent.features[name], data);\n        });\n      }\n    };\n\n    builder.parent = this;\n    return builder;\n  };",
            "fileName": "../src/charts/grouped-column-chart.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.groupedColumnChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.groupedColumnChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.groupedColumnChart = function groupedColumnChart() {\n    var chart = d4.baseChart({\n      accessors: ['groupsOf'],\n      groupsOf: 1\n    }, groupedColumnChartBuilder);\n    [{\n      'bars': d4.features.groupedColumnSeries\n    }, {\n      'columnLabels': d4.features.groupedColumnLabels\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  };\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "groupedColumnChart",
                "string": "d4.groupedColumnChart()"
            },
            "fileName": "../src/charts/grouped-column-chart.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var lineChartBuilder = function() {\n    var extractValues = function(data, key) {\n      var values = data.map(function(obj){\n        return obj.values.map(function(i){\n          return i[key];\n        }.bind(this));\n      }.bind(this));\n      return d3.merge(values);\n    };\n\n    var configureX = function(data) {\n      if (!this.parent.x) {\n        var xData = extractValues(data, this.parent.xKey);\n        this.parent.xRoundBands = this.parent.xRoundBands || 0.3;\n        this.parent.x = d3.scale.ordinal()\n          .domain(xData)\n          .rangeRoundBands([0, this.parent.width - this.parent.margin.left - this.parent.margin.right], this.parent.xRoundBands);\n      }\n    };\n\n    var configureY = function(data) {\n      if (!this.parent.y) {\n        var yData = extractValues(data, this.parent.yKey);\n        var ext = d3.extent(yData);\n        this.parent.y = d3.scale.linear().domain(ext);\n      }\n      this.parent.y.range([this.parent.height - this.parent.margin.top - this.parent.margin.bottom, 0])\n        .clamp(true)\n        .nice();\n    };\n\n    var configureScales = function(data) {\n      configureX.bind(this)(data);\n      configureY.bind(this)(data);\n    };\n\n    var builder = {\n      configure: function(data) {\n        configureScales.bind(this)(data);\n      },\n      render: function(data) {\n        var parent = this.parent;\n        parent.mixins.forEach(function(name) {\n          parent.features[name].render.bind(parent)(parent.features[name], data);\n        });\n      }\n    };\n\n    builder.parent = this;\n    return builder;\n  };",
            "fileName": "../src/charts/line-chart.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>\n\n<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.lineChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>",
                "body": "<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.lineChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.lineChart = function lineChart() {\n    var chart = d4.baseChart({}, lineChartBuilder);\n    [{\n      'linesSeries': d4.features.lineSeries\n    },{\n      'linesSeriesLabels': d4.features.lineSeriesLabels\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  };\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "lineChart",
                "string": "d4.lineChart()"
            },
            "fileName": "../src/charts/line-chart.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var rowChartBuilder = function() {\n    var configureX = function(data) {\n      if (!this.parent.x) {\n        this.parent.x = d3.scale.linear()\n          .domain(d3.extent(data, function(d) {\n            return d[this.parent.xKey];\n          }.bind(this)));\n      }\n      this.parent.x.range([0, this.parent.width - this.parent.margin.right - this.parent.margin.left])\n      .clamp(true)\n      .nice();\n    };\n\n    var configureY = function(data) {\n      if (!this.parent.y) {\n        this.parent.yRoundBands = this.parent.yRoundBands || 0.3;\n        this.parent.y = d3.scale.ordinal()\n          .domain(data.map(function(d) {\n            return d[this.parent.yKey];\n          }.bind(this)))\n          .rangeRoundBands([this.parent.height - this.parent.margin.top - this.parent.margin.bottom, 0], this.parent.yRoundBands);\n      }\n    };\n\n    var configureScales = function(data) {\n      configureX.bind(this)(data);\n      configureY.bind(this)(data);\n    };\n\n    var builder = {\n      configure: function(data) {\n        configureScales.bind(this)(data);\n      },\n      render: function(data) {\n        var parent = this.parent;\n        parent.mixins.forEach(function(name) {\n          parent.features[name].render.bind(parent)(parent.features[name], data);\n        });\n      }\n    };\n\n    builder.parent = this;\n    return builder;\n  };",
            "fileName": "../src/charts/row-chart.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.rowChart();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>",
                "summary": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.rowChart();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>"
            },
            "ignore": false,
            "code": "d4.rowChart = function rowChart() {\n    var chart = d4.baseChart({\n      margin: {\n        top: 20,\n        right: 40,\n        bottom: 20,\n        left: 40\n      }\n    }, rowChartBuilder);\n    [{\n      'bars': d4.features.rowSeries\n    }, {\n      'rowLabels': d4.features.rowLabels\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  };\n}).call(this);",
            "ctx": {
                "type": "method",
                "receiver": "d4",
                "name": "rowChart",
                "string": "d4.rowChart()"
            },
            "fileName": "../src/charts/row-chart.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var scatterPlotBuilder = function() {\n    var configureX = function(data) {\n      if (!this.parent.x) {\n        var ext = d3.extent(data, function(d) {\n          return d[this.parent.xKey];\n        }.bind(this));\n        this.parent.x = d3.scale.linear()\n          .domain(ext)\n          .nice()\n          .clamp(true);\n      }\n      this.parent.x.range([0, this.parent.width - this.parent.margin.left - this.parent.margin.right]);\n    };\n\n    var configureY = function(data) {\n      if (!this.parent.y) {\n        var ext = d3.extent(data, function(d) {\n          return d[this.parent.yKey];\n        }.bind(this));\n        this.parent.y = d3.scale.linear()\n          .domain(ext)\n          .nice()\n          .clamp(true);\n      }\n      this.parent.y.range([this.parent.height - this.parent.margin.top - this.parent.margin.bottom, 0]);\n    };\n\n    var configureZ = function(data) {\n      if (!this.parent.z) {\n        var ext = d3.extent(data, function(d) {\n          return d[this.parent.zKey];\n        }.bind(this));\n        this.parent.z = d3.scale.linear()\n          .domain(ext)\n          .nice()\n          .clamp(true);\n      }\n      var maxSize = (this.parent.height - this.parent.margin.top - this.parent.margin.bottom);\n      this.parent.z.range([maxSize / data.length, maxSize / (data.length * 5)]);\n    };\n    var configureScales = function(data) {\n      configureX.bind(this)(data);\n      configureY.bind(this)(data);\n      configureZ.bind(this)(data);\n    };\n\n    var builder = {\n      configure: function(data) {\n        configureScales.bind(this)(data);\n      },\n      render: function(data) {\n        var parent = this.parent;\n        parent.mixins.forEach(function(name) {\n          parent.features[name].render.bind(parent)(parent.features[name], data);\n        });\n      }\n    };\n\n    builder.parent = this;\n    return builder;\n  };\n\n  d4.scatterPlot = function() {\n    var chart = d4.baseChart({\n      accessors: ['z', 'zKey'],\n      zKey: 'z'\n    }, scatterPlotBuilder);\n    [{\n      'scatterSeries': d4.features.scatterSeries\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  };\n}).call(this);",
            "fileName": "../src/charts/scatter-plot.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  var stackedColumnChartBuilder = function() {\n    var extractValues = function(data, key) {\n      var values = data.map(function(obj){\n        return obj.values.map(function(i){\n          return i[key];\n        }.bind(this));\n      }.bind(this));\n      return d3.merge(values);\n    };\n\n    var configureX = function(data) {\n      if (!this.parent.x) {\n        var xData = extractValues(data, this.parent.xKey);\n        this.parent.xRoundBands = this.parent.xRoundBands || 0.3;\n        this.parent.x = d3.scale.ordinal()\n          .domain(xData)\n          .rangeRoundBands([0, this.parent.width - this.parent.margin.left - this.parent.margin.right], this.parent.xRoundBands);\n      }\n    };\n\n    var configureY = function(data) {\n      if (!this.parent.y) {\n        var ext = d3.extent(d3.merge(data.map(function(obj){\n          return d3.extent(obj.values, function(d){\n            return d.y + d.y0;\n          });\n        })));\n        this.parent.y = d3.scale.linear().domain([Math.min(0, ext[0]),ext[1]]);\n      }\n      this.parent.y.range([this.parent.height - this.parent.margin.top - this.parent.margin.bottom, 0])\n        .clamp(true)\n        .nice();\n    };\n\n    var configureScales = function(data) {\n      configureX.bind(this)(data);\n      configureY.bind(this)(data);\n    };\n\n    var builder = {\n      configure: function(data) {\n        configureScales.bind(this)(data);\n      },\n\n      render: function(data) {\n        var parent = this.parent;\n        parent.mixins.forEach(function(name) {\n          parent.features[name].render.bind(parent)(parent.features[name], data);\n        });\n      }\n    };\n\n    builder.parent = this;\n    return builder;\n  };\n\n  d4.stackedColumnChart = function stackedColumnChart() {\n    var chart = d4.baseChart({}, stackedColumnChartBuilder);\n    [{\n      'bars': d4.features.stackedColumnSeries\n    }, {\n      'columnLabels': d4.features.stackedColumnLabels\n    }, {\n      'connectors': d4.features.stackedColumnConnectors\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n    return chart;\n  };\n}).call(this);",
            "fileName": "../src/charts/stacked-column-chart.js"
        },
        {
            "tags": [],
            "description": {
                "full": "<p>global d3: false<br />global d4: false</p>",
                "summary": "<p>global d3: false<br />global d4: false</p>",
                "body": ""
            },
            "ignore": true,
            "code": "'use strict';\n\n  // This accessor can be overridden\n  var orientation = function() {\n    return 'vertical';\n  };\n\n  // FIXME: It would be nice not to continually have to check the orientation.\n  var columnSeriesOverrides = function() {\n    return {\n      accessors: {\n        y: function(d) {\n          if (this.orientation() === 'vertical') {\n            var yVal = (d.y0 + d.y) - Math.min(0, d.y);\n            return this.y(yVal);\n          } else {\n            return this.y(d[this.yKey]);\n          }\n        },\n\n        x: function(d) {\n          if (this.orientation() === 'vertical') {\n            return this.x(d[this.xKey]);\n          } else {\n            var xVal = (d.y0 + d.y) - Math.max(0, d.y);\n            return this.x(xVal);\n          }\n        },\n\n        width: function(d) {\n          if (this.orientation() === 'vertical') {\n            return this.x.rangeBand();\n          } else {\n            return Math.abs(this.x(d.y0) - this.x(d.y0 + d.y));\n          }\n        },\n\n        height: function(d) {\n          if (this.orientation() === 'vertical') {\n            return Math.abs(this.y(d.y0) - this.y(d.y0 + d.y));\n          } else {\n            return this.y.rangeBand();\n          }\n        },\n\n        classes: function(d, i, n) {\n          var klass = (d.y > 0) ? 'positive' : 'negative';\n          if (n > 0 && d.y0 === 0) {\n            klass = 'subtotal';\n          }\n          return 'bar fill item' + i + ' ' + klass + ' ' + d[this.yKey];\n        }\n      }\n    };\n  };\n\n  var columnLabelOverrides = function() {\n    return {\n      accessors: {\n        y: function(d) {\n          if (this.orientation() === 'vertical') {\n            var height = Math.abs(this.y(d.y0) - this.y(d.y0 + d.y));\n            var yVal = (d.y0 + d.y) - Math.max(0, d.y);\n            return this.y(yVal) - 10 - height;\n          } else {\n            return this.y(d[this.yKey]) + (this.y.rangeBand() / 2);\n          }\n        },\n        x: function(d) {\n          if (this.orientation() === 'vertical') {\n            return this.x(d[this.xKey]) + (this.x.rangeBand() / 2);\n          } else {\n            var xVal = (d.y0 + d.y) - Math.max(0, d.y);\n            var width = Math.abs(this.x(d.y0) - this.x(d.y0 + d.y));\n            return this.x(xVal) + 10 + width;\n          }\n        },\n        text: function(d) {\n          return d3.format('').call(this, d[this.valueKey]);\n        }\n      }\n    };\n  };\n\n  var waterfallChartBuilder = function() {\n    var rangeBoundsFor = function(dimension) {\n      var rangeBounds;\n      if (dimension === 'x') {\n        return [0, this.parent.width - this.parent.margin.left - this.parent.margin.right];\n      } else {\n        rangeBounds = [0, this.parent.height - this.parent.margin.top - this.parent.margin.bottom];\n        return (this.parent.orientation().toLowerCase() === 'vertical') ? rangeBounds.reverse() : rangeBounds;\n      }\n    };\n\n    var setOrdinal = function(dimension, data) {\n      if (!this.parent[dimension]) {\n        var keys = data.map(function(d) {\n          return d.key;\n        }.bind(this));\n\n        this.parent[dimension] = d3.scale.ordinal()\n          .domain(keys)\n          .rangeRoundBands(rangeBoundsFor.bind(this)(dimension), this.parent.xRoundBands || 0.3);\n      }\n    };\n\n    var setLinear = function(dimension, data) {\n      if (!this.parent[dimension]) {\n        var ext = d3.extent(d3.merge(data.map(function(datum) {\n          return d3.extent(datum.values, function(d) {\n\n            // This is anti-intuative but the stack only returns y and y0 even\n            // when it applies to the x dimension;\n            return d.y + d.y0;\n          });\n        })));\n        ext[0] = Math.min(0, ext[0]);\n        this.parent[dimension] = d3.scale.linear()\n          .domain(ext);\n      }\n      this.parent[dimension].range(rangeBoundsFor.bind(this)(dimension))\n        .clamp(true)\n        .nice();\n    };\n\n    var configureScales = function(data) {\n      if (this.parent.orientation().toLowerCase() === 'vertical') {\n        setOrdinal.bind(this)('x', data);\n        setLinear.bind(this)('y', data);\n      } else {\n        setOrdinal.bind(this)('y', data);\n        setLinear.bind(this)('x', data);\n      }\n    };\n\n    var builder = {\n      configure: function(data) {\n        configureScales.bind(this)(data);\n      },\n\n      render: function(data) {\n        var parent = this.parent;\n        parent.mixins.forEach(function(name) {\n          parent.features[name].render.bind(parent)(parent.features[name], data);\n        });\n      }\n    };\n\n    builder.parent = this;\n    return builder;\n  };\n\n  d4.waterfallChart = function waterfallChart() {\n    var chart = d4.baseChart({\n      accessors: ['orientation'],\n      orientation: orientation\n    }, waterfallChartBuilder);\n    [{\n      'bars': d4.features.stackedColumnSeries,\n      'overrides': columnSeriesOverrides\n    }, {\n      'connectors': d4.features.waterfallConnectors\n    }, {\n      'columnLabels': d4.features.stackedColumnLabels,\n      'overrides': columnLabelOverrides\n    }, {\n      'xAxis': d4.features.xAxis\n    }, {\n      'yAxis': d4.features.yAxis\n    }].forEach(function(feature) {\n      chart.mixin(feature);\n    });\n\n    return chart;\n  };\n}).call(this);",
            "fileName": "../src/charts/waterfall-chart.js"
        }
    ],
    "mox": [
        {},
        {},
        {},
        {
            "params": [
                {
                    "types": [
                        "Varies"
                    ],
                    "name": "funct",
                    "description": "- An function or other variable to be wrapped in a function"
                }
            ],
            "name": "functor",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                "summary": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                "body": ""
            }
        },
        {},
        {
            "params": [
                {
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                },
                {
                    "types": [
                        "Function"
                    ],
                    "name": "funct",
                    "description": "- function which will perform the modifcation."
                }
            ],
            "name": "using",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>\n\n<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>",
                "summary": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>"
            }
        },
        {
            "params": [
                {
                    "types": [
                        "Object"
                    ],
                    "name": "feature",
                    "description": "- an object describing the feature to mix in."
                },
                {
                    "types": [
                        "Integer"
                    ],
                    "name": "index",
                    "description": "- an optional number to specify the insertion layer."
                }
            ],
            "name": "mixin",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>",
                "summary": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>"
            }
        },
        {
            "params": [
                {
                    "types": [
                        "String"
                    ],
                    "name": "name",
                    "description": "- accessor name for chart feature."
                }
            ],
            "name": "mixout",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                "summary": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
            }
        },
        {
            "params": [],
            "name": "features",
            "type": "method",
            "fileName": "../src/base.js",
            "description": {
                "full": "<p>To see what features are currently mixed into your chart you can use<br />this method.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                "summary": "<p>To see what features are currently mixed into your chart you can use<br />this method.</p>",
                "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
            }
        },
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {
            "params": [],
            "name": "waterfallConnectors",
            "type": "method",
            "fileName": "../src/features/waterfall-connectors.js",
            "description": {
                "full": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>\n\n<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>",
                "summary": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>",
                "body": "<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>"
            }
        },
        {},
        {},
        {},
        {},
        {
            "params": [],
            "name": "nestedGroup",
            "type": "method",
            "fileName": "../src/parsers/nested-group.js",
            "description": {
                "full": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>\n\n<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>",
                "summary": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>",
                "body": "<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>"
            }
        },
        {},
        {},
        {
            "params": [],
            "name": "nestedStack",
            "type": "method",
            "fileName": "../src/parsers/nested-stack.js",
            "description": {
                "full": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>\n\n<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>",
                "summary": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>",
                "body": "<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>"
            }
        },
        {},
        {},
        {
            "params": [],
            "name": "waterfall",
            "type": "method",
            "fileName": "../src/parsers/waterfall.js",
            "description": {
                "full": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>\n\n<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>",
                "summary": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>",
                "body": "<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>"
            }
        },
        {},
        {
            "params": [],
            "name": "columnChart",
            "type": "method",
            "fileName": "../src/charts/column-chart.js",
            "description": {
                "full": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.columnChart();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.columnChart()\n.xKey(0)\n.yKey(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.columnChart();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.columnChart()\n.xKey(0)\n.yKey(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>"
            }
        },
        {},
        {
            "params": [],
            "name": "groupedColumnChart",
            "type": "method",
            "fileName": "../src/charts/grouped-column-chart.js",
            "description": {
                "full": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.groupedColumnChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.groupedColumnChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
            }
        },
        {},
        {
            "params": [],
            "name": "lineChart",
            "type": "method",
            "fileName": "../src/charts/line-chart.js",
            "description": {
                "full": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>\n\n<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.lineChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                "summary": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>",
                "body": "<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.lineChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
            }
        },
        {},
        {
            "params": [],
            "name": "rowChart",
            "type": "method",
            "fileName": "../src/charts/row-chart.js",
            "description": {
                "full": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.rowChart();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>",
                "summary": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>",
                "body": "<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.rowChart();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>"
            }
        },
        {},
        {},
        {}
    ],
    "categories": [],
    "files": [
        {
            "tag": "../src/base.js",
            "moxComments": [
                {
                    "params": [
                        {
                            "types": [
                                "Varies"
                            ],
                            "name": "funct",
                            "description": "- An function or other variable to be wrapped in a function"
                        }
                    ],
                    "name": "functor",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                        "summary": "<p>Based on D3's own functor function.</p>\n\n<blockquote>\n  <p>If the specified value is a function, returns the specified value. Otherwise,<br />returns a function that returns the specified value. This method is used<br />internally as a lazy way of upcasting constant values to functions, in<br />cases where a property may be specified either as a function or a constant.<br />For example, many D3 layouts allow properties to be specified this way,<br />and it simplifies the implementation if we automatically convert constant<br />values to functions.</p>\n</blockquote>",
                        "body": ""
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "String"
                            ],
                            "name": "name",
                            "description": "- accessor name for chart feature."
                        },
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "funct",
                            "description": "- function which will perform the modifcation."
                        }
                    ],
                    "name": "using",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>\n\n<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>",
                        "summary": "<p>The heart of the d4 API is the <code>using</code> function, which allows you to<br />contextually modify attributes of the chart or one of its features.</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code> chart.mixin({ 'zeroLine': d4.features.referenceLine })\n .using('zeroLine', function(zero) {\n   zero\n     .x1(function() {\n       return this.x(0);\n     })\n });\n</code></pre>"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "Object"
                            ],
                            "name": "feature",
                            "description": "- an object describing the feature to mix in."
                        },
                        {
                            "types": [
                                "Integer"
                            ],
                            "name": "index",
                            "description": "- an optional number to specify the insertion layer."
                        }
                    ],
                    "name": "mixin",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>",
                        "summary": "<p>Specifies a feature to be mixed into a given chart.<br />The feature is an object where the key represents the feature name, and a<br />value which is a function that when invoked returns a d4 feature object.</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code> // Mix in a feature at a specific depth\n chart.mixin({ 'grid': d4.features.grid }, 0)\n\n chart.mixin({ 'zeroLine': d4.features.referenceLine })\n</code></pre>"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "String"
                            ],
                            "name": "name",
                            "description": "- accessor name for chart feature."
                        }
                    ],
                    "name": "mixout",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                        "summary": "<p>Specifies an existing feature of a chart to be removed (mixed out).</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
                    }
                },
                {
                    "params": [],
                    "name": "features",
                    "type": "method",
                    "fileName": "../src/base.js",
                    "description": {
                        "full": "<p>To see what features are currently mixed into your chart you can use<br />this method.</p>\n\n<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>",
                        "summary": "<p>To see what features are currently mixed into your chart you can use<br />this method.</p>",
                        "body": "<h5>Examples</h5>\n\n<pre><code> // Mixout the yAxis which is provided as a default\n var chart = d4.columnChart()\n .mixout('yAxis');\n\n // Now test that the feature has been removed.\n console.log(chart.features());\n =&gt; [\"bars\", \"barLabels\", \"xAxis\"]\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/features/waterfall-connectors.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "waterfallConnectors",
                    "type": "method",
                    "fileName": "../src/features/waterfall-connectors.js",
                    "description": {
                        "full": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>\n\n<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>",
                        "summary": "<p>Waterfall connectors are orthogonal series connectors which visually join<br />column series together by spanning the top or bottom of adjacent columns.</p>",
                        "body": "<p>When using this feature in charts other than waterfall, be aware that the<br />mixin expects an accessor property for <code>orientation</code>, which it uses to render<br />the direction of the lines.</p>\n\n<h5>Accessors</h5>\n\n<p><code>x</code> - Used in placement of the connector lines.<br /><code>y</code> - Used in placement of the connector lines.<br /><code>span</code> - calculates the length of the connector line<br /><code>classes</code> - applies the class to the connector lines.</p>"
                    }
                }
            ]
        },
        {
            "tag": "../src/parsers/nested-group.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "nestedGroup",
                    "type": "method",
                    "fileName": "../src/parsers/nested-group.js",
                    "description": {
                        "full": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>\n\n<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>",
                        "summary": "<p>The nested group parser is useful for grouped column charts where multiple<br />data items need to appear relative to the axis value, for example grouped<br />column charts or multi-series line charts.</p>",
                        "body": "<pre><code>_____________________\n|           _        |\n|   _ _    | |_      |\n|  | | |   | | |     |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the waterfall data. Here is a simple<br />example. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }</p>\n\n<pre><code>var parser = d4.parsers.nestedGroup()\n    .x('category')\n    .y('value')\n    .value('value');\n\nvar groupedColumnData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h4>Accessor Methods</h4>\n\n<p><code>x</code> - A function which returns a key to access the x values in the data array<br /><code>y</code> - A function which returns a key to access the y values in the data array<br /><code>value</code> - A function which returns a key to access the values in the data array.<br /><code>data</code> - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [\n{\"year\" : \"2010\", \"category\" : \"Category One\", \"value\" : 23 },\n{\"year\" : \"2010\", \"category\" : \"Category Two\", \"value\" : 55 },\n{\"year\" : \"2010\", \"category\" : \"Category Three\", \"value\" : -10 },\n{\"year\" : \"2010\", \"category\" : \"Category Four\", \"value\" : 5 }]\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/parsers/nested-stack.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "nestedStack",
                    "type": "method",
                    "fileName": "../src/parsers/nested-stack.js",
                    "description": {
                        "full": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>\n\n<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>",
                        "summary": "<p>The nested stack parser is useful for charts which take a data series<br />  and wants to sort them across a dimension and then display the results.<br />  The most common usecase would be a stacked column chart like this:</p>",
                        "body": "<pre><code>_____________________\n|    _               |\n|   | |   _          |\n|   |-|  | |   _     |\n|   |-|  |-|  |-|    |\n|   | |  |-|  |-|    |\n----------------------\n</code></pre>\n\n<p>This module makes use of the d3's \"nest\" data structure, and \"stack\" layout</p>\n\n<p><a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a><br /><a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a></p>\n\n<h4>Approach</h4>\n\n<p>Just like D3, this parser uses a chaining declaritiave style to build up<br />the necessary prerequistes to create the stacked data. Here is a simple<br />example:</p>\n\n<pre><code>    var parser = d4.parsers.nestedStack()\n        .x(function() {\n          return 'title';\n        })\n        .y(function(){\n          return 'group';\n        })\n        .value(function() {\n          return 'values';\n        });\n\n    var stackedData = parser(data);\n</code></pre>\n\n<p>Keep reading for more information on these various accessor functions.</p>\n\n<h5>Benefits</h5>\n\n<ul>\n<li>Supports negative and positive stacked data series.</li>\n</ul>\n\n<h5>Limitations</h5>\n\n<ul>\n<li>The parser expects the stack will occur on the yAxis, which means it is only suitable for column charts presently.</li>\n</ul>\n\n<h5>Accessor Methods</h5>\n\n<p><code>x</code> : - function which returns a key to access the x values in the data array<br /><code>y</code> : - function which returns a key to access the y values in the data array<br /><code>value</code> : - function which returns a key to access the values in the data array.<br /><code>data</code> : array - An array of objects with their dimensions specified like this:</p>\n\n<pre><code>var data = [{ \"title\": \"3 Years\", \"group\" : \"one\", \"value\": 30 },\n            { \"title\": \"3 Years\", \"group\" : \"two\", \"value\": 20 },\n            { \"title\": \"3 Years\", \"group\" : \"three\", \"value\": 10 },\n            { \"title\": \"5 Years\", \"group\" : \"one\",  \"value\": 3 },\n            { \"title\": \"5 Years\", \"group\" : \"two\", \"value\": 2 },\n            { \"title\": \"5 Years\", \"group\" : \"three\", \"value\": 1 }]\n</code></pre>\n\n<h5>Example Usage</h5>\n\n<p>Given the example data and dimension variables above you can use this module<br />in the following way:</p>\n\n<pre><code>var parser = d4.parsers.nestedStack()\n.x(function() {\n  return 'title';\n})\n.y(function(){\n  return 'group';\n})\n.value(function() {\n  return 'value';\n})\n.call(data);\n</code></pre>\n\n<p>The <code>parser</code> variable will now be an object containing the following structure:</p>\n\n<pre><code>{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/parsers/waterfall.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "waterfall",
                    "type": "method",
                    "fileName": "../src/parsers/waterfall.js",
                    "description": {
                        "full": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>\n\n<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>",
                        "summary": "<p>The waterfall parser is useful for waterfall charts where data items need to account<br />    for the position of earlier values:</p>",
                        "body": "<pre><code>_____________________\n|   _        _______ |\n|  |_|___   | |  | | |\n|      |_|__|_|  | | |\n|                |_| |\n----------------------\n\nThis module makes use of the d3's \"nest\" data structure, and \"stack\" layout\n<a href='https://github.com/mbostock/d3/wiki/Arrays#-nest'>https://github.com/mbostock/d3/wiki/Arrays#-nest</a>\n<a href='https://github.com/mbostock/d3/wiki/Stack-Layout'>https://github.com/mbostock/d3/wiki/Stack-Layout</a>\n\n\nApproach:\nJust like D3, this parser uses a chaining declaritiave style to build up\nthe necessary prerequistes to create the waterfall data. Here is a simple\nexample. Given a data item structure like this: {\"category\" : \"Category One\", \"value\" : 23 }\n\nvar parser = d4.parsers.waterfall()\n    .x(function() {\n      return 'category';\n    })\n    .y(function(){\n      return 'value';\n    })\n    .value(function() {\n      return 'value';\n    });\n\nvar waterfallData = parser(data);\n\nKeep reading for more information on these various accessor functions.\n\nBenefits:\n</code></pre>\n\n<p>Supports horizontal or vertical waterfalls<br />Supports totaling series using a special \"e\" value in a data item.</p>\n\n<pre><code>Limitations:\n</code></pre>\n\n<p>Does not support stacked waterfalls.</p>\n\n<pre><code>Accessor Methods:\n</code></pre>\n\n<p>x : - function which returns a key to access the x values in the data array<br />y : - function which returns a key to access the y values in the data array<br />value : - function which returns a key to access the values in the data array.<br />data : array - An array of objects with their dimensions specified<br />      like this:</p>\n\n<pre><code>  var data = [\n  {\"category\" : \"Category One\", \"value\" : 23 },\n  {\"category\" : \"Category Two\", \"value\" : 55 },\n  {\"category\" : \"Category Three\", \"value\" : -10 },\n  {\"category\" : \"Category Four\", \"value\" : 5 },\n  {\"category\" : \"Category Five\", \"value\" : \"e\" }]\n\nSPECIAL NOTE:\nWaterfalls charts typically have the ability to display subtotals at any point.\nIn order to use this feature simply set the value of your subtotal column to \"e.\"\n\nExample Usage:\nGiven the example data and dimension variables above you can use this module\nin the following way:\n\nvar parser = d4.parsers.nestedStack()\n.dimensions(dimensions)\n.call(data);\n\nThe `parser` variable will now be an object containing the following structure:\n{\n  data: Array\n  value: {\n    key: string,\n    values: Array\n  },\n  x: {\n    key: string,\n    values: Array\n  },\n  y: {\n    key: string,\n    values: Array\n  }\n}\n\nTaking these attributes one-by-one:\n</code></pre>\n\n<p>data - is an array of items stacked by D3<br />value - an object with a key representing the value accessor and an array of values<br />x - an object with a key representing the x accessor and an array of values<br />y - an object with a key representing the y accessor and an array of values</p>"
                    }
                }
            ]
        },
        {
            "tag": "../src/charts/column-chart.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "columnChart",
                    "type": "method",
                    "fileName": "../src/charts/column-chart.js",
                    "description": {
                        "full": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.columnChart();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.columnChart()\n.xKey(0)\n.yKey(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>",
                        "summary": "<p>The column chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear values for the <code>y</code> and ordinal values on the <code>x</code>. The basic column chart<br />   has four default features:</p>",
                        "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n    { x: '2010', y:-10 },\n    { x: '2011', y:20 },\n    { x: '2012', y:30 },\n    { x: '2013', y:40 },\n    { x: '2014', y:50 },\n  ];\nvar chart = d4.columnChart();\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>\n\n<p>By default d4 expects a series object, which uses the following format: <code>{ x : '2010', y : 10 }</code>.<br />The default format may not be desired and so we'll override it:</p>\n\n<pre><code>var data = [\n  ['2010', -10],\n  ['2011', 20],\n  ['2012', 30],\n  ['2013', 40],\n  ['2014', 50]\n];\nvar chart = d4.columnChart()\n.xKey(0)\n.yKey(1);\n\nd3.select('#example')\n.datum(data)\n.call(chart);\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/charts/grouped-column-chart.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "groupedColumnChart",
                    "type": "method",
                    "fileName": "../src/charts/grouped-column-chart.js",
                    "description": {
                        "full": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.groupedColumnChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                        "summary": "<p>The grouped column chart is used to compare a series of data elements grouped<br />along the xAxis. This chart is often useful in conjunction with a stacked column<br />chart because they can use the same data series, and where the stacked column highlights<br />the sum of the data series across an axis the grouped column can be used to show the<br />relative distribution.</p>",
                        "body": "<p><strong>bars</strong> - series bars<br /><strong>barLabels</strong> - data labels above the bars<br /><strong>groupsOf</strong> - an integer representing the number of columns in each group<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\n\nvar parsedData = d4.parsers.nestedGroup()\n  .x('year')\n  .y('unitsSold')\n  .value('unitsSold')(data);\n\nvar chart = d4.groupedColumnChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold')\n.groupsOf(parsedData.data[0].values.length);\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/charts/line-chart.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "lineChart",
                    "type": "method",
                    "fileName": "../src/charts/line-chart.js",
                    "description": {
                        "full": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>\n\n<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.lineChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>",
                        "summary": "<p>The line series chart is used to compare a series of data elements grouped<br />  along the xAxis.</p>",
                        "body": "<p><strong>lineSeries</strong> - series lines<br /><strong>lineSeriesLabels</strong> - data labels beside the lines<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n  { year: '2010', unitsSold:-100, salesman : 'Bob' },\n  { year: '2011', unitsSold:200, salesman : 'Bob' },\n  { year: '2012', unitsSold:300, salesman : 'Bob' },\n  { year: '2013', unitsSold:400, salesman : 'Bob' },\n  { year: '2014', unitsSold:500, salesman : 'Bob' },\n  { year: '2010', unitsSold:100, salesman : 'Gina' },\n  { year: '2011', unitsSold:100, salesman : 'Gina' },\n  { year: '2012', unitsSold:-100, salesman : 'Gina' },\n  { year: '2013', unitsSold:500, salesman : 'Gina' },\n  { year: '2014', unitsSold:600, salesman : 'Gina' },\n  { year: '2010', unitsSold:400, salesman : 'Average' },\n  { year: '2011', unitsSold:0, salesman : 'Average' },\n  { year: '2012', unitsSold:400, salesman : 'Average' },\n  { year: '2013', unitsSold:400, salesman : 'Average' },\n  { year: '2014', unitsSold:400, salesman : 'Average' }\n];\nvar parsedData = d4.parsers.nestedGroup()\n  .x(function(){\n    return 'year';\n  })\n  .nestKey(function(){\n    return 'salesman';\n  })\n  .y(function(){\n    return 'unitsSold';\n  })\n  .value(function(){\n    return 'unitsSold';\n  })(data);\n\nvar chart = d4.lineChart()\n.width($('#example').width())\n.xKey('year')\n.yKey('unitsSold');\n\nd3.select('#example')\n.datum(parsedData.data)\n.call(chart);\n</code></pre>"
                    }
                }
            ]
        },
        {
            "tag": "../src/charts/row-chart.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "rowChart",
                    "type": "method",
                    "fileName": "../src/charts/row-chart.js",
                    "description": {
                        "full": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>\n\n<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.rowChart();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>",
                        "summary": "<p>The row chart has two axes (<code>x</code> and <code>y</code>). By default the column chart expects<br />   linear scale values for the <code>x</code> and ordinal scale values on the <code>y</code>. The basic column chart<br />   has four default features:</p>",
                        "body": "<p><strong>bars</strong> - series bars<br /><strong>rowLabels</strong> - data labels to the right of the bars<br /><strong>xAxis</strong> - the axis for the x dimension<br /><strong>yAxis</strong> - the axis for the y dimension</p>\n\n<h5>Example Usage</h5>\n\n<pre><code>var data = [\n      { y: '2010', x:-10 },\n      { y: '2011', x:20 },\n      { y: '2012', x:30 },\n      { y: '2013', x:40 },\n      { y: '2014', x:50 },\n    ];\n  var chart = d4.rowChart();\n  d3.select('#example')\n  .datum(data)\n  .call(chart);\n</code></pre>"
                    }
                }
            ]
        }
    ],
    "name": "d4",
    "version": "0.1.0"
}